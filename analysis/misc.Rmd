---
title: "Misc"
author: "Haider Inam"
date: "4/3/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Here I include some miscellaneous, pre-prod analyses
```{r,include=F}
# rm(list=ls())
library(knitr)
library(tictoc)
library(workflowr)
library(VennDiagram)
library(dplyr)
library(foreach)
library(doParallel)
library(ggplot2)
library(reshape2)
library(RColorBrewer)
library(devtools)
library(ggsignif)
library(plotly)
library(BiocManager)
library(drc)
# library(ensembldb) #Loading this with Dplyr commands seems to throw an error in Rmd
# library(EnsDb.Hsapiens.v86) #Loading this with Dplyr commands seems to throw an error in Rmd

######################Cleanup for GGPlot2#########################################
cleanup=theme_bw() +
  theme(plot.title = element_text(hjust=.5),
        panel.grid.major = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(color = "black"),
        axis.text = element_text(face="bold",color="black",size="11"),
        text=element_text(size=11,face="bold"),
        axis.title=element_text(face="bold",size="11"))
```


###Modeling out confidence intervals on growth rate predictions from IC50s
Sources of error:
1. Sampling error (reads). Will be estimated by
* Multinomial distributions based on observed coverages.
* Sampling error in observed reads may be eliminated by removing mutants with <=1 depth of coverage  

2. Dose response variability
* Well known observation that IC50s can vary by as much as 50%. Will incorporate this into predictions. One direct, albeit simple, solution is  to just take the 95% confidence intervals of the IC50s that fell in the dose response range.

3. Dose variability. i.e. error between your expected dose and dose response.

Getting the dose responses for all mutants with the errors.
```{r}
net_gr_wodrug=0.055
########################Reading IC50 Data########################
ic50data_all=read.csv("data/IC50HeatMap.csv",header = T,stringsAsFactors = F)
# ic50data_all=read.csv("../data/IC50HeatMap.csv",header = T,stringsAsFactors = F)

twinstrand_maf_merge=read.csv("output/twinstrand_maf_merge.csv",header = T,stringsAsFactors = F)
# twinstrand_maf_merge=read.csv("../output/twinstrand_maf_merge.csv",header = T,stringsAsFactors = F)

ic50data_all=ic50data_all%>%filter(species%in%c("Wt","V299L_H","E355A","D276G_maxi","H396R","F317L","F359I","E459K","G250E","F359C","F359V","M351T","L248V","E355G_maxi","Q252H_maxi","Y253F","F486S_maxi","H396P_maxi","E255K","Y253H","T315I","E255V"))


ic50data_all=ic50data_all%>%
  mutate(species=case_when(species=="F486S_maxi"~"F486S",
                          species=="H396P_maxi"~"H396P",
                          species=="Q252H_maxi"~"Q252H",
                          species=="E355G_maxi"~"E355G",
                          species=="D276G_maxi"~"D276G",
                          species=="V299L_H" ~ "V299L",
                          TRUE ~as.character(species)))

########################Getting Confidence Intervals########################
#will just start of with one dose at 1.25uM
ic50data_all2=data.frame(cbind(ic50data_all$species,ic50data_all$X1.25))
# ic50data_all2=data.frame(cbind(ic50data_all$species,ic50data_all$X0.625))
colnames(ic50data_all2)=c("species","dose_response")
ic50data_all2$dose_response=as.numeric(as.character(ic50data_all2$dose_response))


#Calculating confidence limit and standard deviations
ic50data_all_sum=ic50data_all2%>%group_by(species)%>%summarise(dr_mean=mean(dose_response),dr_ci_ul=dr_mean+1.96*sd(dose_response)*sqrt(n()),dr_ci_ll=dr_mean-1.96*sd(dose_response)*sqrt(n()),dr_sd_ul=dr_mean+sd(dose_response),dr_sd_ll=dr_mean-sd(dose_response))

#Since some mutants have 0% alive at the lower limit of the confidence interval, I'm converting those to 0
ic50data_all_sum=ic50data_all_sum%>%mutate(dr_ci_ll=case_when(dr_ci_ll<=0~0,
                                                              TRUE~dr_ci_ll),
                                           dr_sd_ll=case_when(dr_sd_ll<=0~0,
                                                              TRUE~dr_sd_ll))

#Dose response here is essentially y. aka %alive
#Converting y to drug effect on growth rate aka alpha value
ic50data_all_sum=ic50data_all_sum%>%mutate(netgr_pred_mean=net_gr_wodrug-(-log(dr_mean)/72),netgr_pred_ci_ul=net_gr_wodrug-(-log(dr_ci_ul)/72),netgr_pred_ci_ll=net_gr_wodrug-(-log(dr_ci_ll)/72),netgr_pred_sd_ul=net_gr_wodrug-(-log(dr_sd_ul)/72),netgr_pred_sd_ll=net_gr_wodrug-(-log(dr_sd_ll)/72))


########################Plotting Count with CIs########################
twinstrand_maf_merge=twinstrand_maf_merge%>%mutate(MAF=AltDepth/Depth)
twinstrand_maf_merge=merge(twinstrand_maf_merge%>%
                                 filter(experiment=="M3",tki_resistant_mutation=="True",!mutant%in%c("D276G",NA)),ic50data_all_sum%>%
                                 dplyr::select(species,netgr_pred_mean,netgr_pred_ci_ul,netgr_pred_ci_ll,netgr_pred_sd_ul,netgr_pred_sd_ll),by.x="mutant",by.y="species")

twinstrand_simple=twinstrand_maf_merge%>%dplyr::select(AltDepth,Depth,tki_resistant_mutation,mutant,experiment,Spike_in_freq,time_point,totalcells,totalmutant,MAF,netgr_pred_mean,netgr_pred_ci_ul,netgr_pred_ci_ll,netgr_pred_sd_ul,netgr_pred_sd_ll)

twinstrand_merge_forplot=melt(twinstrand_simple,id.vars = c("AltDepth","Depth","tki_resistant_mutation","mutant","experiment","Spike_in_freq","time_point","totalcells","netgr_pred_mean","netgr_pred_ci_ul","netgr_pred_ci_ll","netgr_pred_sd_ul","netgr_pred_sd_ll"),variable.name = "count_type",value.name = "count")
# twinstrand_merge_forplot=merge(twinstrand_maf_merge%>%filter(experiment=="M3",tki_resistant_mutation=="True",!mutant%in%c("D276G",NA)),ic50data_all_sum%>%dplyr::select(species,netgr_pred_mean,netgr_pred_ci_ul,netgr_pred_ci_ll,netgr_pred_sd_ul,netgr_pred_sd_ll),by.x="mutant",by.y="species")

#Basically making an extra column with the D0 total mutant counts for each mutant
twinstrand_merge_forplot=merge(twinstrand_merge_forplot,twinstrand_merge_forplot%>%filter(time_point=="D0")%>%dplyr::select(mutant,count_type,count_D0=count),by=c("mutant","count_type"))
#########Here, figure out why twinstrand_merge_forplot is having two rows for each mutant after being merged with a D0 version of itself. This is leading to weird plotting artifacts

a=twinstrand_merge_forplot%>%filter(count_type=="totalmutant",mutant=="E255K",time_point=="D0")
############
twinstrand_merge_forplot=twinstrand_merge_forplot%>%mutate(time=case_when(time_point=="D0"~0,
                            time_point=="D3"~72,
                            time_point=="D6"~144),
                           ci_mean=count_D0*exp(netgr_pred_mean*time),
                           ci_ul=count_D0*exp(netgr_pred_ci_ul*time),
                           ci_ll=count_D0*exp(netgr_pred_ci_ll*time),
                           sd_ul=count_D0*exp(netgr_pred_sd_ul*time),
                           sd_ll=count_D0*exp(netgr_pred_sd_ll*time),)
twinstrand_merge_forplot=twinstrand_merge_forplot%>%mutate(ci_ll=case_when(ci_ll=="NaN"~0,
                                           TRUE~ci_ll))

#Factoring the mutants from more to less resistant
twinstrand_merge_forplot$mutant=factor(twinstrand_merge_forplot$mutant,levels = as.character(unique(twinstrand_merge_forplot$mutant[order((twinstrand_merge_forplot$netgr_pred_mean),decreasing = T)])))


getPalette = colorRampPalette(brewer.pal(9, "Spectral"))
####In the plots below, the dashed line is the mean prediction form the IC50s. Points are what we see in the spike-in experiment

#Plotting with 95% confidence intervals
# %>%filter(count_type=="totalmutant")
ggplot(twinstrand_merge_forplot,aes(x=time/24,y=count,fill=factor(mutant)))+geom_point()+
  facet_grid(count_type~mutant)+
  geom_line(aes(y=ci_mean),linetype="dashed")+
  geom_ribbon(aes(ymin=ci_ll,ymax=ci_ul,alpha=.3))+
  scale_y_continuous(trans="log2")+
  cleanup+
  scale_fill_manual(values = getPalette(length(unique(twinstrand_merge_forplot$mutant))))

#Plotting with standard deviations
ggplot(twinstrand_merge_forplot,aes(x=time/24,y=count,fill=factor(mutant),shape=factor(count_type)))+geom_point()+
  geom_line(aes(y=ci_mean),linetype="dashed")+
  geom_ribbon(aes(ymin=sd_ll,ymax=sd_ul,alpha=.3))+
  facet_wrap(~mutant,ncol=4)+
  scale_y_continuous(trans="log2")+
  cleanup+
  scale_fill_manual(values = getPalette(length(unique(twinstrand_merge_forplot$mutant))))
#Next step: extend for experiments besides M3

ggplot(twinstrand_merge_forplot%>%filter(count_type=="totalmutant"),aes(x=time/24,y=count,fill=factor(mutant),sahpe=factor(count_type)))+geom_point()+
  geom_line(aes(y=ci_mean),linetype="dashed")+
  geom_ribbon(aes(ymin=sd_ll,ymax=sd_ul,alpha=.3))+
  facet_wrap(~mutant,ncol=4)+
  scale_y_continuous(trans="log2")+
  cleanup+
  scale_fill_manual(values = getPalette(length(unique(twinstrand_merge_forplot$mutant))))
# a=twinstrand_merge_forplot%>%filter(count_type=="totalmutant",mutant=="E255K")
```
Next step: Is our method better than the Shendure method?
1. Can they make accurate predicitons?
2. Does their method still work for measuring gain of funciton phenotypes?
3. Do they have enough coverage given a detection efficiency of 10,000?
Assume you make 1,000 mutants
Given a detection efficiency of 1 in 10,000, for mutants treated with drug for a specified amount of time, how many mutants will you get enough coverage for?

Can you use just mutant allele frequency, without count data? I.e. does that data match expected growth?
